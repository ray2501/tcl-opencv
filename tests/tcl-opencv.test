# tcl-opencv.test --
#
#   Tests for tcl-opencv
#------------------------------------------------------------------------------

lappend auto_path .
if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest 2
    namespace import -force ::tcltest::*
}
loadTestedCommands
package require opencv

testConstraint DNN [expr {[info command ::cv::dnn::blobFromImage] ne {}}]

#-------------------------------------------------------------------------------

test opencv-1.1 {read image, wrong # args} {*}{
    -body {
        ::cv::imread
    }
    -returnCodes error
    -match glob
    -result {wrong # args*}
}

test opencv-1.2 {read image, no image} {*}{
    -body {
        ::cv::imread aaa
    }
    -returnCodes error
    -match glob
    -result {no image data}
}

test opencv-1.3 {write image, wrong # args} {*}{
    -body {
        ::cv::imwrite
    }
    -returnCodes error
    -match glob
    -result {wrong # args*}
}

test opencv-1.4 {write image, wrong # args} {*}{
    -body {
        ::cv::imwrite aaa
    }
    -returnCodes error
    -match glob
    -result {wrong # args*}
}

test opencv-1.5 {read image} {*}{
    -body {
        set image [::cv::imread "tests/logoLarge.png"]
    }
    -returnCodes ok
    -match glob
    -result {cv-mat-*}
}

test opencv-1.6 {resize image, wrong # args} {*}{
    -body {
        set image2 [::cv::resize $image 177]
    }
    -returnCodes error
    -match glob
    -result {wrong # args*}
}

test opencv-1.7 {resize image} {*}{
    -body {
        set image2 [::cv::resize $image 177 260]
        $image2 close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.8 {image color space, wrong # args} {*}{
    -body {
        set image3 [::cv::cvtColor $image]
    }
    -returnCodes error
    -match glob
    -result {wrong # args*}
}

test opencv-1.9 {image color space} {*}{
    -body {
        set image3 [::cv::cvtColor $image $::cv::COLOR_BGR2RGB]
        $image3 close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.10 {crop image, wrong # args} {*}{
    -body {
        set image4 [$image crop]
    }
    -returnCodes error
    -match glob
    -result {wrong # args*}
}

test opencv-1.11 {crop image} {*}{
    -body {
        set image4 [$image crop 110 110 210 410]
        $image4 close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.12 {getRotationMatrix2D, wrong # args} {*}{
    -body {
        set image5 [::cv::getRotationMatrix2D]
    }
    -returnCodes error
    -match glob
    -result {wrong # args*}
}

test opencv-1.13 {warpAffine, wrong # args} {*}{
    -body {
        set image5 [::cv::warpAffine]
    }
    -returnCodes error
    -match glob
    -result {wrong # args*}
}

test opencv-1.14 {Rotate} {*}{
    -body {
        set x [expr [$image cols] / 2]
        set y [expr [$image rows] / 2]
        set image5 [::cv::getRotationMatrix2D $x $y 45.0 1.0]
        set image6 [::cv::warpAffine $image $image5 [$image cols] [$image rows]]
        $image6 close
        $image5 close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.15 {VideoCapture, wrong # args} {*}{
    -body {
        set v [::cv::VideoCapture]
    }
    -returnCodes error
    -match glob
    -result {wrong # args*}
}

test opencv-1.16 {Draw a line, wrong # args} {*}{
    -body {
        ::cv::line $image
    }
    -returnCodes error
    -match glob
    -result {wrong # args*}
}

test opencv-1.17 {Draw a line} {*}{
    -body {
        ::cv::line $image 50 50 250 400 [list 255 255 0 0] 5 $::cv::LINE_AA 0
    }
    -returnCodes ok
}

test opencv-1.18 {Draw a line} {*}{
    -body {
        ::cv::line $image 60 60 260 310 [list 255 0 255 0] 1
    }
    -returnCodes ok
}

test opencv-1.19 {Draw a arrowedLine, wrong # args} {*}{
    -body {
        ::cv::arrowedLine $image
    }
    -returnCodes error
    -match glob
    -result {wrong # args*}
}

test opencv-1.20 {Draw a arrowedLine} {*}{
    -body {
        set scalar [list 0 0 255 0]
        ::cv::arrowedLine $image 50 40 40 410 $scalar 3 $::cv::LINE_8 0 0.1
    }
    -returnCodes ok
}

test opencv-1.21 {Draw a arrowedLine} {*}{
    -body {
        set scalar [list 128 128 64 0]
        ::cv::arrowedLine $image 150 40 40 410 $scalar 1
    }
    -returnCodes ok
}

test opencv-1.22 {Draw a circle, wrong # args} {*}{
    -body {
        ::cv::circle $image
    }
    -returnCodes error
    -match glob
    -result {wrong # args*}
}

test opencv-1.23 {Draw a circle} {*}{
    -body {
        set scalar [list 0 255 0 0]
        ::cv::circle $image 170 250 50 $scalar -1 $::cv::LINE_8 0
    }
    -returnCodes ok
}

test opencv-1.24 {Draw a circle} {*}{
    -body {
        set scalar [list 255 255 0 0]
        ::cv::circle $image 170 250 100 $scalar 1
    }
    -returnCodes ok
}

test opencv-1.25 {clipLine, wrong # args} {*}{
    -body {
        ::cv::clipLine
    }
    -returnCodes error
    -match glob
    -result {wrong # args*}
}

test opencv-1.26 {clipLine test} {*}{
    -body {
        set result [::cv::clipLine [list 300 500] [list 5 5] [list 250 450]]
    }
    -returnCodes ok
    -result {1}
}

test opencv-1.27 {drawMarker test} {*}{
    -body {
        ::cv::drawMarker $image 150 150 [list 0 255 255 0]
    }
    -returnCodes ok
}

test opencv-1.28 {drawMarker test} {*}{
    -body {
        ::cv::drawMarker $image 150 300 [list 255 63 128 0] \
                         $::cv::MARKER_STAR 30 3 $::cv::LINE_4
    }
    -returnCodes ok
}

test opencv-1.29 {Draw a rectangle, wrong # args} {*}{
    -body {
        ::cv::rectangle $image
    }
    -returnCodes error
    -match glob
    -result {wrong # args*}
}

test opencv-1.30 {Draw a rectangle} {*}{
    -body {
        ::cv::rectangle $image 250 10 300 200 [list 0 128 255 0] 4 $::cv::LINE_8 0
    }
    -returnCodes ok
}

test opencv-1.31 {Draw a rectangle} {*}{
    -body {
        ::cv::rectangle $image 310 210 100 400 [list 63 128 255 0] 1
    }
    -returnCodes ok
}

test opencv-1.32 {Put a text, wrong # args} {*}{
    -body {
        ::cv::putText $image
    }
    -returnCodes error
    -match glob
    -result {wrong # args*}
}

test opencv-1.33 {Put a text} {*}{
    -body {
        ::cv::putText $image "Let go!" 10 410 $::cv::FONT_ITALIC 1.5 [list 250 225 100 0] 1
    }
    -returnCodes ok
}

test opencv-1.34 {Put a text} {*}{
    -body {
        set color [list 100 225 250 0]
        ::cv::putText $image "Tcl/Tk" 100 460 $::cv::FONT_HERSHEY_COMPLEX 1.5 $color 5 $::cv::LINE_4 0
    }
    -returnCodes ok
}

test opencv-1.35 {Draw a ellipse, wrong # args} {*}{
    -body {
        ::cv::ellipse $image
    }
    -returnCodes error
    -match glob
    -result {wrong # args*}
}

test opencv-1.36 {Draw a ellipse} {*}{
    -body {
        ::cv::ellipse $image 210 210 150 75 0 0 360 [list 240 0 100 0] 1
    }
    -returnCodes ok
}

test opencv-1.37 {Draw a ellipse} {*}{
    -body {
        ::cv::ellipse $image 210 210 100 50 0 0 180 [list 0 191 191 0] -2 $::cv::LINE_AA 0
    }
    -returnCodes ok
}

test opencv-1.38 {namedWindow} {*}{
    -body {
        ::cv::namedWindow "Display"
    }
    -returnCodes ok
}

test opencv-1.39 {destroyAllWindows} {*}{
    -body {
        ::cv::destroyAllWindows
    }
    -returnCodes ok
}

test opencv-1.40 {threshold, wrong # args} {*}{
    -body {
        ::cv::threshold $image
    }
    -returnCodes error
    -match glob
    -result {wrong # args*}
}

test opencv-1.41 {threshold test} {*}{
    -body {
        set image8 [::cv::imread "tests/logoLarge.png" $::cv::IMREAD_GRAYSCALE]
        set image9 [::cv::threshold $image8 128 255 0]
        $image9 close
        $image8 close

    }
    -returnCodes ok
    -result {0}
}

test opencv-1.42 {equalizeHist test} {*}{
    -body {
        set image10 [::cv::cvtColor $image $::cv::COLOR_BGR2GRAY]
        set image11 [::cv::equalizeHist $image10]
        $image11 close
        $image10 close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.43 {Sobel test} {*}{
    -body {
        set image12 [::cv::cvtColor $image $::cv::COLOR_BGR2GRAY]
        set image13 [::cv::Sobel $image12 1 0]
        $image13 close
        $image12 close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.44 {Sobel test} {*}{
    -body {
        set image12 [::cv::cvtColor $image $::cv::COLOR_BGR2GRAY]
        set image13 [::cv::Sobel $image12 0 1 5 1.0 0.0 $::cv::BORDER_DEFAULT]
        $image13 close
        $image12 close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.45 {Sobel test} {*}{
    -body {
        set image12 [::cv::cvtColor $image $::cv::COLOR_BGR2GRAY]
        set image13 [::cv::Sobel $image12 1 1 5 1.0 0.0 $::cv::BORDER_ISOLATED]
        $image13 close
        $image12 close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.46 {Scharr test} {*}{
    -body {
        set image12 [::cv::cvtColor $image $::cv::COLOR_BGR2GRAY]
        set image13 [::cv::Scharr $image12 1 0 1.0 0.0 $::cv::BORDER_ISOLATED]
        $image13 close
        $image12 close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.47 {Scharr test} {*}{
    -body {
        set image12 [::cv::cvtColor $image $::cv::COLOR_BGR2GRAY]
        set image13 [::cv::Scharr $image12 0 1 1.0 0.0 $::cv::BORDER_ISOLATED]
        $image13 close
        $image12 close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.48 {Canny test} {*}{
    -body {
        set image12 [::cv::cvtColor $image $::cv::COLOR_BGR2GRAY]
        set image13 [::cv::Canny $image12 100 200 3 0]
        $image13 close
        $image12 close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.49 {Canny test} {*}{
    -body {
        set image12 [::cv::cvtColor $image $::cv::COLOR_BGR2GRAY]
        set image13 [::cv::Canny $image12 100 200]
        $image13 close
        $image12 close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.50 {Draw a polylines, wrong # args} {*}{
    -body {
        ::cv::polylines $image
    }
    -returnCodes error
    -match glob
    -result {wrong # args*}
}

test opencv-1.51 {Draw a polylines} {*}{
    -body {
        ::cv::polylines $image [list 50 50 300 50 350 200 300 150 150 350 100 100] \
                               1 0 [list 31 255 0 0] 1
    }
    -returnCodes ok
}

test opencv-1.52 {Draw a fillConvexPoly, wrong # args} {*}{
    -body {
        ::cv::fillConvexPoly $image [list 0 0 100 100 200 200]
    }
    -returnCodes error
    -match glob
    -result {wrong # args*}
}

test opencv-1.53 {Draw a fillConvexPoly} {*}{
    -body {
        ::cv::fillConvexPoly $image [list 0 0 100 100 200 200] [list 0 255 31 0]
    }
    -returnCodes ok
}

test opencv-1.54 {Draw a fillConvexPoly, with zeros image} {*}{
    -body {
        set image14 [::cv::Mat::zeros 600 800 [::cv::CV_8UC 3]]
        set points [list 0 0 50 150 400 400 410 50]
        ::cv::fillConvexPoly $image14 $points [list 0 255 63 0] $::cv::LINE_8 0
        $image14 close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.55 {Draw a polylines, with ones image} {*}{
    -body {
        set image14 [::cv::Mat::ones 600 800 [::cv::CV_8UC 1]]
        ::cv::polylines $image14 [list 50 50 300 50 550 200 400 150 160 500 100 100] 1 1 [list 128 0 0 0] 5 $::cv::LINE_8 0
        $image14 close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.56 {Eye image} {*}{
    -body {
        set image15 [::cv::Mat::eye 4 4 $::cv::CV_64FC1]
        $image15 close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.57 {Split and merge image} {*}{
    -body {
        set imgList [::cv::split $image]
        set len [llength $imgList]
        set img2 [::cv::merge $imgList]

        for {set i 0} {$i < $len} {incr i} {
            set myimage [lindex $imgList $i]
            $myimage close
        }
    }
    -returnCodes ok
}


test opencv-1.58 {Split and merge image} {*}{
    -body {
        set imgList [::cv::split $image]
        set len [llength $imgList]
        set img2 [::cv::cvtColor $image $::cv::COLOR_BGR2YCrCb]
        set simg [::cv::split $img2]
        set simg0 [lindex $simg 0]
        set simg1 [lindex $simg 1]
        set simg2 [lindex $simg 2]

        set simg0m [::cv::equalizeHist $simg0]
        set afterimg [list $simg0m $simg1 $simg2]

        set img3 [::cv::merge $afterimg]
        set img4 [::cv::cvtColor $img3 $::cv::COLOR_YCrCb2BGR]

        $simg0 close
        $simg1 close
        $simg2 close
        $simg0m close
        $img2 close
        $img3 close
        $img4 close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.59 {flip image} {*}{
    -body {
        set img [::cv::flip $image 0]
        $img close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.60 {morphologyEx test} {*}{
    -body {
        set matrix [cv::getStructuringElement $::cv::MORPH_RECT 5 5]
        set img [::cv::morphologyEx $image $::cv::MORPH_ERODE $matrix]
        $matrix close
        $img close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.61 {morphologyEx test} {*}{
    -body {
        set matrix [cv::getStructuringElement $::cv::MORPH_RECT 5 5]
        set img [::cv::morphologyEx $image $::cv::MORPH_DILATE $matrix -1 -1 1]
        $matrix close
        $img close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.62 {Matrix at test} {*}{
    -body {
        set matrix [::cv::Mat::Mat 1 1 $::cv::CV_64FC1 [list 1 0 0 0]]
        set matrix2 [::cv::multiply $matrix $matrix 2]
        $matrix2 at [list 0 0] 0
    }
    -returnCodes ok
    -result {2.0}
}

test opencv-1.63 {Matrix convertTo test} {*}{
    -body {
        set matrix3 [$matrix2 convertTo [::cv::CV_8UC 1]]
        $matrix3 at [list 0 0] 0
    }
    -returnCodes ok
    -result {2}
}

test opencv-1.64 {Matrix close test} {*}{
    -body {
        $matrix close
        $matrix2 close
        $matrix3 close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.65 {copyMakeBorder and floodFill image} {*}{
    -body {
        set img [::cv::copyMakeBorder $image 20 20 20 20 $::cv::BORDER_CONSTANT [list 255 31 31 0]]

        ::cv::floodFill $img 150 50 [list 127 255 127 0] [list 0 0 0 0] \
                  [list 20 20 20 0] [list 20 20 20 0] [expr 4  | $::cv::FLOODFILL_FIXED_RANGE]

        $img close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.66 {absdiff test} {*}{
    -body {
        set matrix [::cv::Mat::Mat 1 3 [::cv::CV_8UC 1] [list 10 0 0 0]]
        set matrix2 [::cv::Mat::Mat 1 3 [::cv::CV_8UC 1] [list 40 0 0 0]]
        set matrix3 [::cv::absdiff $matrix $matrix2]
        $matrix3 at [list 0 0] 0
    }
    -returnCodes ok
    -result {30}
}

test opencv-1.67 {matrix size test} {*}{
    -body {
        set nmatrix [::cv::Mat::MatWithDims 3 [list 1 3 1] [::cv::CV_8UC 1] [list 10 0 0 0]]
        $nmatrix size
    }
    -returnCodes ok
    -result {1 3 1}
}

test opencv-1.68 {MatWithDims test} {*}{
    -body {
        set nmatrix [::cv::Mat::MatWithDims 3 [list 1 3 1] [::cv::CV_8UC 1] [list]]
    }
    -returnCodes error
    -match glob
    -result {invalid color data*}
}

test opencv-1.69 {dft test} {*}{
    -body {
        set img [::cv::imread "tests/logoLarge.png" $::cv::IMREAD_GRAYSCALE]

        set width [::cv::getOptimalDFTSize [$img cols]]
        set height [::cv::getOptimalDFTSize [$img rows]]

        set zeros [::cv::Mat::zeros [$img rows] [$img cols] $::cv::CV_32FC1]
        set newimage [$img convertTo $::cv::CV_32FC1 1 0]
        set merges [::cv::merge [list $newimage $zeros]]
        set dft_result [::cv::dft $merges]
        set splits [::cv::split $dft_result]
        set magI [::cv::magnitude [lindex $splits 0] [lindex $splits 1]]

        $zeros close
        $newimage close
        $merges close
        $dft_result close
        [lindex $splits 0] close
        [lindex $splits 1] close

        set mat [::cv::Mat::ones [$magI rows] [$magI cols] $::cv::CV_32FC1]
        set magI2 [::cv::add $magI $mat]
        set magI3 [::cv::log $magI2]
        set magI4 [$magI3 crop 0 0 [expr [$magI3 cols] & -2] [expr [$magI3 rows] & -2]]

        $mat close
        $magI close
        $magI2 close
        $magI3 close

        set cx [expr [$magI4 cols]/2]
        set cy [expr [$magI4 rows]/2]

        set q0 [$magI4 rect 0 0 $cx $cy]
        set q1 [$magI4 rect $cx 0 $cx $cy]
        set q2 [$magI4 rect 0 $cy $cx $cy]
        set q3 [$magI4 rect $cx $cy $cx $cy]

        set tmp [::cv::Mat::Mat $cy $cx $::cv::CV_32FC1]
        $q0 copyTo $tmp
        $q3 copyTo $q0
        $tmp copyTo $q3

        $q1 copyTo $tmp
        $q2 copyTo $q1
        $tmp copyTo $q2

        $q0 close
        $q1 close
        $q2 close
        $q3 close
        $tmp close

        set img2 [::cv::normalize $magI4 0 1 $::cv::NORM_MINMAX]

        # Display code
        #::cv::namedWindow "Display Image" $::cv::WINDOW_AUTOSIZE
        #::cv::imshow "Display Image" $img2
        #::cv::waitKey 0
        #::cv::destroyAllWindows

        $magI4 close
        $img close
        $img2 close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.70 {blobFromImage test} {*}{
    -body {
        set blob [::cv::dnn::blobFromImage $image 1.0 [$image cols] [$image rows] \
                  [list 104 177 123 0] 1 1]
        $blob dims
    }
    -constraints DNN
    -returnCodes ok
    -result {4}
}

test opencv-1.71 {match test} {*}{
    -body {
        set method $::cv::TM_SQDIFF
        set mimage [::cv::matchTemplate $image $image $method]

        set mimage2 [::cv::normalize $mimage 0 1 $::cv::NORM_MINMAX]
        set result [::cv::minMaxLoc $mimage2]
        set matchLoc_x [lindex [lindex $result 0] 1]
        set matchLoc_y [lindex [lindex $result 0] 2]

        ::cv::namedWindow "Display Image" $::cv::WINDOW_AUTOSIZE
        ::cv::rectangle $image $matchLoc_x $matchLoc_y \
            [expr $matchLoc_x + [$image cols]] \
            [expr $matchLoc_y + [$image rows]] \
            [list 0 0 255 0] 5 $::cv::LINE_8 0

        #::cv::imshow "Display Image" $image
        #::cv::waitKey 0
        ::cv::destroyAllWindows

        $mimage close
        $mimage2 close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.72 {match test} {*}{
    -body {
        set method $::cv::TM_CCOEFF
        set mimage [::cv::matchTemplate $image $image $method]

        set mimage2 [::cv::normalize $mimage 0 1 $::cv::NORM_MINMAX]
        set result [::cv::minMaxLoc $mimage2]
        set matchLoc_x [lindex [lindex $result 1] 1]
        set matchLoc_y [lindex [lindex $result 1] 2]

        ::cv::namedWindow "Display Image" $::cv::WINDOW_AUTOSIZE
        ::cv::rectangle $image $matchLoc_x $matchLoc_y \
            [expr $matchLoc_x + [$image cols]] \
            [expr $matchLoc_y + [$image rows]] \
            [list 0 0 255 0] 5 $::cv::LINE_8 0

        #::cv::imshow "Display Image" $image
        #::cv::waitKey 0
        ::cv::destroyAllWindows

        $mimage close
        $mimage2 close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.73 {calcHist test} {*}{
    -body {
        set hbins 30
        set sbins 32
        set hsv [::cv::cvtColor $image $::cv::COLOR_BGR2HSV]
        set mask [::cv::Mat::Mat 0 0 $::cv::CV_8U]
        set dst [::cv::calcHist $hsv [list 0 1] $mask 2 [list $hbins $sbins] \
                [list 0 180 0 256] \
                1 0]

        set minmax [::cv::minMaxLoc $dst]
        set minvalue [lindex [lindex $minmax 0] 0]
        set maxvalue [lindex [lindex $minmax 1] 0]

        set histImg [::cv::Mat::zeros [expr $sbins*10] [expr $hbins*10] $::cv::CV_8UC3]

        for {set i 0} {$i < $hbins} {incr i} {
            for {set j 0} {$j < $sbins} {incr j} {
                set binval [$dst at [list $i $j] 0]
                set intensity [expr round($binval * 255 / $maxvalue)]
                ::cv::rectangle $histImg [expr $i * 10] [expr $j * 10] \
                    [expr ($i + 1) * 10 - 1] [expr ($j + 1) * 10 - 1] \
                    [list $intensity $intensity $intensity $intensity] -1 $::cv::LINE_8 0
            }
        }

        #::cv::namedWindow "Display Image" $::cv::WINDOW_AUTOSIZE
        #::cv::imshow "Display Image" $histImg
        #::cv::waitKey 0
        #::cv::destroyAllWindows

        $hsv close
        $dst close
        $mask close
        $histImg close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.74 {Stitcher create test} {*}{
    -body {
        set colorimage [::cv::applyColorMap $image $::cv::COLORMAP_RAINBOW]
        $colorimage close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.75 {Stitcher create test} {*}{
    -body {
        set s [::cv::Stitcher $::cv::PANORAMA]
        $s close
    }
    -returnCodes ok
}

test opencv-1.76 {diag test} {*}{
    -body {
        set mat1 [::cv::Mat::Mat 3 3 $::cv::CV_8U]
        $mat1 setData [list 1 2 3 4 5 6 7 8 9]
        set mat2 [$mat1 diag 0]
        set mat3 [::cv::Mat::diag $mat2]
        $mat3 size
    }
    -returnCodes ok
    -result {3 3}
}

test opencv-1.77 {inv test} {*}{
    -body {
        set tmatrix1 [::cv::Mat::Mat 2 2 $::cv::CV_32F]
        $tmatrix1 setData [list 3 2 -6 6]
        set tmatrix2 [::cv::Mat::Mat 2 1 $::cv::CV_32F]
        $tmatrix2 setData [list 7 6]
        set tmatrix3 [$tmatrix1 inv]
        set tmatrix4 [$tmatrix3 * $tmatrix2]
        $tmatrix4 at [list 1 0] 0
    }
    -returnCodes ok
    -result {2.0}
}

test opencv-1.78 {remap test} {*}{
    -body {
        set map1 [::cv::Mat::Mat [$image rows] [$image cols] $::cv::CV_32FC1]
        set map2 [::cv::Mat::Mat [$image rows] [$image cols] $::cv::CV_32FC1]

        for {set i 0} {$i < [$map1 rows]} {incr i} {
            for {set j 0} {$j < [$map1 cols]} {incr j} {
                $map1 at [list $i $j] 0 $j
                $map2 at [list $i $j] 0 [expr [$map1 rows] - $i]
            }
        }

        set imagedst [::cv::remap $image $map1 $map2 $::cv::INTER_LINEAR]
        #::cv::namedWindow "Display Image" $::cv::WINDOW_AUTOSIZE
        #::cv::imshow "Display Image" $imagedst

        #::cv::waitKey 0
        #::cv::destroyAllWindows

        $map1 close
        $map2 close
        $imagedst close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.79 {StereoBM test} {*}{
    -body {
        set testimg1 [::cv::imread "tests/tsukuba_l.png" 0]
        set testimg2 [::cv::imread "tests/tsukuba_r.png" 0]

        set stereoBM [::cv::StereoBM 16 15]
        set disparity [$stereoBM compute $testimg1 $testimg2]
        set mresult [::cv::minMaxLoc $disparity]
        set min [lindex [lindex $mresult 0] 0]
        set max [lindex [lindex $mresult 1] 0]
        set disparity2 [$disparity convertTo $::cv::CV_8UC1 [expr 255/($max-$min)] 0]

        #::cv::namedWindow "Display" $::cv::WINDOW_AUTOSIZE
        #::cv::imshow "Display" $disparity2
        #::cv::waitKey 0
        #::cv::destroyAllWindows

        $stereoBM close
        $disparity close
        $disparity2 close
        $testimg1 close
        $testimg2 close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.80 {StereoSGBM test} {*}{
    -body {
        set testimg1 [::cv::imread "tests/tsukuba_l.png"]
        set testimg2 [::cv::imread "tests/tsukuba_r.png"]

        set stereoSGBM [::cv::StereoSGBM 0 48 9 0 0 0 0 0 0 0 $::cv::StereoSGBM_MODE_SGBM]
        set disparity [$stereoSGBM compute $testimg1 $testimg2]
        set mresult [::cv::minMaxLoc $disparity]
        set min [lindex [lindex $mresult 0] 0]
        set max [lindex [lindex $mresult 1] 0]
        set disparity2 [$disparity convertTo $::cv::CV_8UC1 [expr 255/($max-$min)] 0]

        #::cv::namedWindow "Display" $::cv::WINDOW_AUTOSIZE
        #::cv::imshow "Display" $disparity2
        #::cv::waitKey 0
        #::cv::destroyAllWindows

        $stereoSGBM close
        $disparity close
        $disparity2 close
        $testimg1 close
        $testimg2 close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.81 {Compare test} {*}{
    -body {
        set testimg1 [::cv::imread "tests/tsukuba_l.png"]
        set testimg2 [::cv::imread "tests/tsukuba_r.png"]
        set testimg3 [::cv::compare $testimg1 $testimg2 $cv::CMP_NE]

        #::cv::namedWindow "Display" $::cv::WINDOW_AUTOSIZE
        #::cv::imshow "Display" $testimg3
        #::cv::waitKey 0
        #::cv::destroyAllWindows

        $testimg1 close
        $testimg2 close
        $testimg3 close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.82 {encode/decode image} {*}{
    -body {
        set image1 [::cv::imread "tests/logoLarge.png"]
        set bytes1 [::cv::imencode ".png" $image1]
        set image2 [::cv::imdecode $bytes1]
        set bytes2 [::cv::imencode ".png" $image2]
        $image1 close
        $image2 close
        string compare $bytes1 $bytes2
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.83 {Simple SVM test} {*}{
    -body {
        set labels [list 1 -1 -1 -1]
        set trainingData [list 501 10 255 10 501 255 10 501]

        set labelsMat [::cv::Mat::Mat 4 1 $::cv::CV_32SC1]
        $labelsMat setData $labels
        set trainingDataMat [::cv::Mat::Mat 4 2 $::cv::CV_32F]
        $trainingDataMat setData $trainingData

        set term [::cv::TermCriteria $::cv::COUNT 100 0.000001]

        set svm [::cv::ml::SVM]
        $svm setType $::cv::ml::SVM_C_SVC
        $svm setKernel $::cv::ml::SVM_LINEAR
        $svm setTermCriteria $term

        set trainData [::cv::ml::TrainData $trainingDataMat $::cv::ml::ROW_SAMPLE $labelsMat]
        $svm train $trainData

        set width 512
        set height 512
        set result_image [::cv::Mat::zeros $height $width $::cv::CV_8UC3]
        for {set i 0} {$i < $height} {incr i} {
            for {set j 0} {$j < $width} {incr j} {
                set sampleMat [::cv::Mat::Mat 1 2 $::cv::CV_32F]
                $sampleMat at [list 0 0] 0 $j
                $sampleMat at [list 0 1] 0 $i

                set response [$svm predict $sampleMat]
                set retval [lindex $response 0]
                set results [lindex $response 1]

                set value [$results at [list 0 0] 0]

                if {$value == 1} {
                    $result_image at [list $i $j] 0 0
                    $result_image at [list $i $j] 1 255
                    $result_image at [list $i $j] 2 0
                } else {
                    $result_image at [list $i $j] 0 255
                    $result_image at [list $i $j] 1 0
                    $result_image at [list $i $j] 2 0
                }

                $results close
                $sampleMat close
            }
        }

        set thickness -1
        ::cv::circle $result_image 501 10 5 [list 0 0 0 0] $thickness
        ::cv::circle $result_image 255 10 5 [list 255 255 255 0] $thickness
        ::cv::circle $result_image 501 255 5 [list 255 255 255 0] $thickness
        ::cv::circle $result_image 10 501 5 [list 255 255 255 0] $thickness

        set sv [$svm getUncompressedSupportVectors]
        for {set i 0} {$i < [$sv rows]} {incr i} {
            set v0 [expr int([$sv at [list $i 0] 0])]
            set v1 [expr int([$sv at [list $i 1] 0])]
            ::cv::circle $result_image $v0 $v1 6 [list 128 128 128 0] 2
        }
        $sv close

        ::cv::imwrite "result.png" $result_image

        $trainData close
        $svm close
        $labelsMat close
        $trainingDataMat close
        $term close
        $result_image close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.84 {Mahalanobis test} {*}{
    -body {
        set testm [::cv::Mat::Mat 10 2 $::cv::CV_32F]
        $testm setData [list 1.5 2.3 3.0 1.7 1.2 2.9 2.1 2.2 3.1 3.1 \
                             1.3 2.7 2.0 1.7 1.0 2.0 0.5 0.6 1.0 0.9]

        set cal [::cv::calcCovarMatrix $testm \
                 [expr $::cv::COVAR_SCALE|$::cv::COVAR_ROWS|$::cv::COVAR_NORMAL] \
                 $::cv::CV_32F]
        set avgmatrix [lindex $cal 1]
        set convar [lindex $cal 0]
        set iconvar [$convar inv $::cv::DECOMP_LU]
        set vec [::cv::Mat::Mat 1 2 $::cv::CV_32F]
        $vec setData [list 200 100]
        set result [cv::Mahalanobis $vec $avgmatrix $iconvar]

        $testm close
        $avgmatrix close
        $convar close
        $iconvar close
        $vec close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.85 {FileStorage} {*}{
    -body {
        set image1 [::cv::imread "tests/logoLarge.png"]
        set fs [::cv::FileStorage]
        $fs open "" [expr {
            $::cv::FileStorage::FORMAT_JSON | $::cv::FileStorage::MEMORY | $::cv::FileStorage::WRITE
        }]
        $fs writeMat "image" $image1
        $fs writeString "names" "hello" "world"
        $fs writeInt "dim" [$image1 cols] [$image1 rows]
        set data [$fs close]
        set fs [::cv::FileStorage]
        $fs open $data [expr {
            $::cv::FileStorage::FORMAT_JSON | $::cv::FileStorage::MEMORY | $::cv::FileStorage::READ
        }]
        set image2 [$fs readMat "image"]
        set names [$fs readString "names"]
        set dim [$fs readInt "dim"]
        # OpenCV 3.2 on Debian9: 3 empty elements
        # set keys [$fs keys]
        $fs close
        set bytes1 [::cv::imencode ".png" $image1]
        set bytes2 [::cv::imencode ".png" $image2]
        set ret [string equal $bytes1 $bytes2]
        incr ret [string equal [list "hello" "world"] $names]
        incr ret [string equal [list [$image2 cols] [$image2 rows]] $dim]
        # see comment above
        # incr ret [string compare $keys [list "image" "names" "dim"]]
        $image1 close
        $image2 close
        set ret
    }
    -returnCodes ok
    -result {3}
}

test opencv-1.86 {FileStorage (nested)} {*}{
    -body {
        set fs [::cv::FileStorage]
        $fs open "" [expr {
            $::cv::FileStorage::FORMAT_XML | $::cv::FileStorage::MEMORY | $::cv::FileStorage::WRITE
        }]
        $fs startMap "top"
        $fs writeString "names" "hello" "world"
        $fs writeInt "numbers" 41 42
        $fs endMap
        set data [$fs close]
        set fs [::cv::FileStorage]
        $fs open $data [expr {
            $::cv::FileStorage::FORMAT_XML | $::cv::FileStorage::MEMORY | $::cv::FileStorage::READ
        }]
        set names [$fs readString "top" "names"]
        set numbers [$fs readInt "top" "numbers"]
        $fs close
        set ret [string equal [list "hello" "world"] $names]
        incr ret [string equal [list 41 42] $numbers]
        set ret
    }
    -returnCodes ok
    -result {2}
}

test opencv-1.87 {FileStorage (types)} {*}{
    -body {
        set fs [::cv::FileStorage]
        $fs open "" [expr {
            $::cv::FileStorage::FORMAT_YAML | $::cv::FileStorage::MEMORY | $::cv::FileStorage::WRITE
        }]
        set count 0
        set mat [::cv::Mat::zeros 2 2 [::cv::CV_8UC 1]]
        set name "obj$count"
        incr count
        $fs writeObj $name $mat
        $mat close
        set objlist [list $name]
        set mat [::cv::Mat::zeros 8 1 $::cv::CV_32FC1]
        set trd [::cv::ml::TrainData $mat $::cv::ml::ROW_SAMPLE $mat]
        set name "obj$count"
        incr count
        $fs writeObj $name $trd
        $mat close
        $trd close
        lappend objlist $name
        # These are omitted in the list below
        # due to OpenCV version dependencies:
        #   cv::AffineFeature
        #   cv::SIFT
        foreach cmd {
            cv::TermCriteria
            cv::CLAHE
            cv::GeneralizedHoughBallard
            cv::GeneralizedHoughGuil
            cv::FastFeatureDetector
            cv::AgastFeatureDetector
            cv::MSER
            cv::ORB
            cv::AKAZE
            cv::BRISK
            cv::KAZE
            cv::BFMatcher
            cv::FlannBasedMatcher
            cv::SimpleBlobDetector
            cv::BackgroundSubtractorKNN
            cv::BackgroundSubtractorMOG2
            cv::StereoBM
            cv::StereoSGBM
            cv::AlignMTB
            cv::CalibrateDebevec
            cv::MergeDebevec
            cv::MergeMertens
            cv::TonemapDrago
            cv::TonemapMantiuk
            cv::TonemapReinhard
            cv::ml::LogisticRegression
            cv::ml::NormalBayesClassifier
            cv::ml::KNearest
            cv::ml::SVM
            cv::ml::SVMSGD
            cv::ml::DTrees
            cv::ml::Boost
            cv::ml::RTrees
            cv::ml::ANN_MLP
        } {
            set obj [$cmd]
            set name "obj$count"
            incr count
            $fs writeObj $name $obj
            $obj close
            lappend objlist $name
        }
        set data1 [$fs close]
        set fs [::cv::FileStorage]
        $fs open $data1 [expr {
            $::cv::FileStorage::FORMAT_YAML | $::cv::FileStorage::MEMORY | $::cv::FileStorage::READ
        }]
        foreach name $objlist {
            lappend newlist [$fs readObj $name]
        }
        $fs close
        set fs [::cv::FileStorage]
        $fs open "" [expr {
            $::cv::FileStorage::FORMAT_YAML | $::cv::FileStorage::MEMORY | $::cv::FileStorage::WRITE
        }]
        set count 0
        foreach cmd $newlist {
            set name "obj$count"
            incr count
            $fs writeObj $name $cmd
            $cmd close
        }
        set data2 [$fs close]
        string equal $data1 $data2
    }
    -returnCodes ok
    -result {1}
}

test opencv-1.88 {fitLine test} {*}{
    -body {
        set testimg [::cv::Mat::Mat 480 640 $::cv::CV_8UC3]

        set points [list 48 58 105 98 155 160 202 210 231 232 248 260 320 300 350 360 412 400]

        for {set i 0} {$i < [llength $points]} {incr i 2} {
            cv::circle $testimg [lindex $points $i] [lindex $points [expr $i+1]] 5 [list 0 0 255 0] 2
        }

        set para [::cv::fitLine $points $::cv::DIST_L2 0 0.01 0.01]
        set p0x [lindex $para 0]
        set p0y [lindex $para 1]
        set p1x [lindex $para 2]
        set p1y [lindex $para 3]

        cv::line $testimg $p0x $p0y $p1x $p1y [list 255 0 0 0] 2

        set k [expr ($p1y-$p0y)/($p1x-$p0x)]

        set n0x $p1x
        set n0y $p1y
        set n1x 640
        set n1y [expr $k * 640]

        cv::line $testimg $n0x $n0y $n1x $n1y [list 0 255 0 0] 2

        ::cv::imwrite "line.png" $testimg

        $testimg close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.89 {Thread support} {*}{
    -body {
        set mat [::cv::Mat::zeros 2 2 [::cv::CV_8UC 1]]
        cv::thread::send MyTag $mat
        set mat [::cv::Mat::zeros 2 2 [::cv::CV_8UC 1]]
        cv::thread::send MyTag $mat
        set mat [::cv::Mat::zeros 2 2 [::cv::CV_8UC 1]]
        cv::thread::send MyTag $mat "hello"
        lassign [cv::thread::recv MyTag] mat string
        $mat close
        lassign [cv::thread::recv MyTag] mat string
        $mat close
        cv::thread::send MyTag "None"
        set mat [::cv::Mat::zeros 2 2 [::cv::CV_8UC 1]]
        cv::thread::send MyTag $mat "last"
        if {[info command $mat] eq $mat} {
            error "matrix $mat still present"
        }
        set result [list [cv::thread::info] [cv::thread::info MyTag]]
        lassign [cv::thread::recv MyTag] mat string
        if {$string ne "hello"} {
            error "string not transferred"
        }
        $mat close
        lassign [cv::thread::recv MyTag] mat string
        if {$mat ne "" || $string ne ""} {
            error "mat/string not empty"
        }
        lassign [cv::thread::recv MyTag] mat string
        if {$string ne "last"} {
            error "string not transferred"
        }
        $mat close
        lappend result [cv::thread::info] [cv::thread::info MyTag]
        set t0 [clock seconds]
        cv::thread::recv MyTag 2021
        set t1 [clock seconds]
        lappend result [expr {($t1 - $t0) > 1}]
    }
    -returnCodes ok
    -result {MyTag 3 {} 0 1}
}

test opencv-1.90 {fillPoly, wrong # args} {*}{
    -body {
        ::cv::fillPoly $image
    }
    -returnCodes error
    -match glob
    -result {wrong # args*}
}

test opencv-1.91 {fillPoly test} {*}{
    -body {
        ::cv::fillPoly $image [list [list 100]] [list 255 0 0 0]
    }
    -returnCodes error
    -match glob
    -result {invalid point data}
}

test opencv-1.92 {fillPoly test} {*}{
    -body {
        set points [list [list 100 100 150 150 400 200] [list 250 120 300 100 170 120]]
        cv::fillPoly $image $points [list 64 64 128 0]

        set points [list [list 250 450 200 360 250 360]]
        cv::fillPoly $image $points [list 64 64 128 0] $::cv::LINE_8 0 0 0
    }
    -returnCodes ok
}

test opencv-1.93 {CLAHE test} {*}{
    -body {
        set dogimg1 [::cv::imread "tests/dog.jpeg" $::cv::IMREAD_GRAYSCALE]
        set clahe [::cv::CLAHE]
        set dogimg2 [$clahe apply $dogimg1]
        ::cv::imwrite "dog2.png" $dogimg2

        $clahe close
        $dogimg1 close
        $dogimg2 close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.94 {EMD test} {*}{
    -body {
        set myimage1 [::cv::imread "tests/tsukuba_l.png"]
        set myimage2 [::cv::imread "tests/tsukuba_r.png"]

        set hbins 30
        set sbins 32
        set hsv1 [::cv::cvtColor $myimage1 $::cv::COLOR_BGR2HSV]
        set hsv2 [::cv::cvtColor $myimage2 $::cv::COLOR_BGR2HSV]

        set mask [::cv::Mat::Mat 0 0 $::cv::CV_8U]

        set dst1 [::cv::calcHist $hsv1 [list 0 1] $mask 2 [list $hbins $sbins] \
                [list 0 180 0 256] \
                1 0]
        set hist1 [cv::normalize $dst1 0 1 $::cv::NORM_MINMAX]

        set dst2 [::cv::calcHist $hsv2 [list 0 1] $mask 2 [list $hbins $sbins] \
                [list 0 180 0 256] \
                1 0]
        set hist2 [cv::normalize $dst2 0 1 $::cv::NORM_MINMAX]

        set numrows [expr $hbins * $sbins]

        set sig1 [cv::Mat::Mat $numrows 3 $::cv::CV_32FC1]
        set sig2 [cv::Mat::Mat $numrows 3 $::cv::CV_32FC1]

        for {set h 0} {$h < $hbins} {incr h} {
            for {set s 0} {$s < $sbins} {incr s} {
                set binval1 [$hist1 at [list $h $s] 0]
                $sig1 at [list [expr $h*$sbins+$s] 0] 0 $binval1
                $sig1 at [list [expr $h*$sbins+$s] 1] 0 $h
                $sig1 at [list [expr $h*$sbins+$s] 2] 0 $s

                set binval2 [$hist2 at [list $h $s] 0]
                $sig2 at [list [expr $h*$sbins+$s] 0] 0 $binval2
                $sig2 at [list [expr $h*$sbins+$s] 1] 0 $h
                $sig2 at [list [expr $h*$sbins+$s] 2] 0 $s
            }
        }

        set emd [cv::EMD $sig1 $sig2 $::cv::DIST_L2]

        $mask close
        $sig1 close
        $sig2 close
        $dst1 close
        $hist1 close
        $dst2 close
        $hist2 close
        $hsv1 close
        $hsv2 close
        $myimage1 close
        $myimage2 close
    }
    -returnCodes ok
    -result {0}
}

test opencv-1.95 {Close test} {*}{
    -body {
        ::cv::imwrite output.png $image
        $tmatrix1 close
        $tmatrix2 close
        $tmatrix3 close
        $tmatrix4 close
        $mat1 close
        $mat2 close
        $mat3 close
        if {[info exists blob]} {
            $blob close
        }
        $nmatrix close
        $matrix close
        $matrix2 close
        $matrix3 close
        $image close
    }
    -returnCodes ok
    -result {0}
}

#-------------------------------------------------------------------------------

removeFile dog2.png
removeFile line.png
removeFile result.png
removeFile output.png

cleanupTests

puts ====
puts "Left over objects:"
puts [lsort [cv::_info]]
puts ====
puts "Left over procs:"
puts [lsort [info command ::cv*]]
puts ====

return
